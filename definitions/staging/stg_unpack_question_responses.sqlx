config {
    type: "view",
    assertions: {
        uniqueKey: ["survey_response_id", "src_question_id", "src_question_response_id", "choice_value"],
        nonNull: ["survey_response_id", "src_question_id", "src_question_response_id", "choice_value"],
        rowConditions: []
    },
}

  -- This table will have duplicate rows for multi-select responses
WITH
  unpivoted AS (
  SELECT
    survey_response_id,
    src_response,
    survey_wave_id,
    NULLIF(choice_value, '') AS choice_value
  FROM
    ${ref("stg_bmg_all_waves")}
  UNPIVOT
    (
      -- TODO: can we derive this list from the lookup somehow - seems brittle
      choice_value FOR src_response IN (ql5,
        ql7,
        ql7a_1,
        ql7a_2,
        ql7a_3,
        ql7a_4,
        ql7a_5,
        ql7a_6,
        ql7a_7,
        ql7a_8,
        ql1a_3,
        ql1c_3_1
        )
    )
  )
SELECT
  survey_response_id,
  unpivoted.survey_wave_id,
  unpivoted.src_response AS src_question_response_id,
  questions.src_question_id AS src_question_id,
  questions.question_type,
  CASE
    WHEN questions.question_type = 'single' THEN choice_value
    WHEN questions.question_type = 'multi' THEN REGEXP_EXTRACT(unpivoted.src_response, r'_([^_]*)$')
  END AS choice_value
FROM
  unpivoted
LEFT JOIN
    ${ref("questions")} questions
    -- TODO: think about whether there is a lookup for this as could be brittle
    ON REGEXP_CONTAINS(unpivoted.src_response, '^' || questions.src_question_id || '(_|$)')
WHERE
    -- single response coded values come through in choice_value fine
    questions.question_type = 'single'
    -- multi response are one-hot encoded so that only '1' are required responses
    OR (questions.question_type = 'multi' AND choice_value = '1')
